{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.SimpleMarkdown = factory());\n})(this, function () {\n  'use strict';\n\n  /* @flow */\n  /* @ts-check */\n\n  /**\n   * Simple-Markdown\n   * ===============\n   *\n   * Simple-Markdown's primary goal is to be easy to adapt. It aims\n   * to be compliant with John Gruber's [Markdown Syntax page][1],\n   * but compatiblity with other markdown implementations' edge-cases\n   * will be sacrificed where it conflicts with simplicity or\n   * extensibility.\n   *\n   * If your goal is to simply embed a standard markdown implementation\n   * in your website, simple-markdown is probably not the best library\n   * for you (although it should work). But if you have struggled to\n   * customize an existing library to meet your needs, simple-markdown\n   * might be able to help.\n   *\n   * Many of the regexes and original logic has been adapted from\n   * the wonderful [marked.js](https://github.com/chjj/marked)\n   *\n   * LICENSE (MIT):\n   * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n   *\n   * Portions adapted from marked.js copyright (c) 2011-2014\n   * Christopher Jeffrey (https://github.com/chjj/).\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in\n   * all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n   * THE SOFTWARE.\n   */\n\n  // Typescript language & simple-markdown.d.ts references:\n  /// <reference lib=\"ES2018\" />\n  /// <reference path=\"../simple-markdown.d.ts\" />\n\n  /*::\n  // Flow Type Definitions:\n  \n  type Capture =\n      Array<string> & {index: number} |\n      Array<string> & {index?: number};\n  \n  type Attr = string | number | boolean | null | void;\n  \n  type SingleASTNode = {\n      type: string,\n      [string]: any,\n  };\n  \n  type UnTypedASTNode = {\n      [string]: any\n  };\n  \n  type ASTNode = SingleASTNode | Array<SingleASTNode>;\n  \n  type State = {\n      key?: string | number | void,\n      inline?: ?boolean,\n      [string]: any,\n  };\n  \n  type ReactElement = React$Element<any>;\n  type ReactElements = React$Node;\n  \n  type MatchFunction = { regex?: RegExp } & (\n      source: string,\n      state: State,\n      prevCapture: string\n  ) => ?Capture;\n  \n  type Parser = (\n      source: string,\n      state?: ?State\n  ) => Array<SingleASTNode>;\n  \n  type ParseFunction = (\n      capture: Capture,\n      nestedParse: Parser,\n      state: State,\n  ) => (UnTypedASTNode | ASTNode);\n  \n  type SingleNodeParseFunction = (\n      capture: Capture,\n      nestedParse: Parser,\n      state: State,\n  ) => UnTypedASTNode;\n  \n  type Output<Result> = (\n      node: ASTNode,\n      state?: ?State\n  ) => Result;\n  \n  type NodeOutput<Result> = (\n      node: SingleASTNode,\n      nestedOutput: Output<Result>,\n      state: State\n  ) => Result;\n  \n  type ArrayNodeOutput<Result> = (\n      node: Array<SingleASTNode>,\n      nestedOutput: Output<Result>,\n      state: State\n  ) => Result;\n  \n  type ReactOutput = Output<ReactElements>;\n  type ReactNodeOutput = NodeOutput<ReactElements>;\n  type HtmlOutput = Output<string>;\n  type HtmlNodeOutput = NodeOutput<string>;\n  \n  type ParserRule = {\n      +order: number,\n      +match: MatchFunction,\n      +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n      +parse: ParseFunction,\n  };\n  \n  type SingleNodeParserRule = {\n      +order: number,\n      +match: MatchFunction,\n      +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n      +parse: SingleNodeParseFunction,\n  };\n  \n  type ReactOutputRule = {\n      // we allow null because some rules are never output results, and that's\n      // legal as long as no parsers return an AST node matching that rule.\n      // We don't use ? because this makes it be explicitly defined as either\n      // a valid function or null, so it can't be forgotten.\n      +react: ReactNodeOutput | null,\n  };\n  \n  type HtmlOutputRule = {\n      +html: HtmlNodeOutput | null,\n  };\n  \n  type ArrayRule = {\n      +react?: ArrayNodeOutput<ReactElements>,\n      +html?: ArrayNodeOutput<string>,\n      +[string]: ArrayNodeOutput<any>,\n  };\n  \n  type ParserRules = {\n      +Array?: ArrayRule,\n      +[type: string]: ParserRule,\n  };\n  \n  type OutputRules<Rule> = {\n      +Array?: ArrayRule,\n      +[type: string]: Rule\n  };\n  type Rules<OutputRule> = {\n      +Array?: ArrayRule,\n      +[type: string]: ParserRule & OutputRule,\n  };\n  type ReactRules = {\n      +Array?: {\n          +react: ArrayNodeOutput<ReactElements>,\n      },\n      +[type: string]: ParserRule & ReactOutputRule,\n  };\n  type HtmlRules = {\n      +Array?: {\n          +html: ArrayNodeOutput<string>,\n      },\n      +[type: string]: ParserRule & HtmlOutputRule,\n  };\n  \n  // We want to clarify our defaultRules types a little bit more so clients can\n  // reuse defaultRules built-ins. So we make some stronger guarantess when\n  // we can:\n  type NonNullReactOutputRule = {\n      +react: ReactNodeOutput,\n  };\n  type ElementReactOutputRule = {\n      +react: NodeOutput<ReactElement>,\n  };\n  type TextReactOutputRule = {\n      +react: NodeOutput<string>,\n  };\n  type NonNullHtmlOutputRule = {\n      +html: HtmlNodeOutput,\n  };\n  \n  type DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\n  type TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\n  type LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\n  type DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n  \n  type DefaultRules = {\n      +Array: {\n          +react: ArrayNodeOutput<ReactElements>,\n          +html: ArrayNodeOutput<string>\n      },\n      +heading: DefaultInOutRule,\n      +nptable: DefaultInRule,\n      +lheading: DefaultInRule,\n      +hr: DefaultInOutRule,\n      +codeBlock: DefaultInOutRule,\n      +fence: DefaultInRule,\n      +blockQuote: DefaultInOutRule,\n      +list: DefaultInOutRule,\n      +def: LenientInOutRule,\n      +table: DefaultInOutRule,\n      +tableSeparator: DefaultInRule,\n      +newline: TextInOutRule,\n      +paragraph: DefaultInOutRule,\n      +escape: DefaultInRule,\n      +autolink: DefaultInRule,\n      +mailto: DefaultInRule,\n      +url: DefaultInRule,\n      +link: DefaultInOutRule,\n      +image: DefaultInOutRule,\n      +reflink: DefaultInRule,\n      +refimage: DefaultInRule,\n      +em: DefaultInOutRule,\n      +strong: DefaultInOutRule,\n      +u: DefaultInOutRule,\n      +del: DefaultInOutRule,\n      +inlineCode: DefaultInOutRule,\n      +br: DefaultInOutRule,\n      +text: TextInOutRule,\n  };\n  \n  type RefNode = {\n      type: string,\n      content?: ASTNode,\n      target?: string,\n      title?: string,\n      alt?: string,\n  };\n  \n  // End Flow Definitions\n  */\n  var CR_NEWLINE_R = /\\r\\n?/g;\n  var TAB_R = /\\t/g;\n  var FORMFEED_R = /\\f/g;\n\n  /**\n   * Turn various whitespace into easy-to-process whitespace\n   * @param {string} source\n   * @returns {string}\n   */\n  var preprocess = function (source /* : string */) {\n    return source.replace(CR_NEWLINE_R, '\\n').replace(FORMFEED_R, '').replace(TAB_R, '    ');\n  };\n\n  /**\n   * @param {SimpleMarkdown.OptionalState} givenState\n   * @param {SimpleMarkdown.OptionalState} defaultState\n   * @returns {SimpleMarkdown.State}\n   */\n  var populateInitialState = function (givenState /* : ?State */, defaultState /* : ?State */) /* : State */{\n    var state /* : State */ = givenState || {};\n    if (defaultState != null) {\n      for (var prop in defaultState) {\n        if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n          state[prop] = defaultState[prop];\n        }\n      }\n    }\n    return state;\n  };\n\n  /**\n   * Creates a parser for a given set of rules, with the precedence\n   * specified as a list of rules.\n   *\n   * @param {SimpleMarkdown.ParserRules} rules\n   *     an object containing\n   *     rule type -> {match, order, parse} objects\n   *     (lower order is higher precedence)\n   * @param {SimpleMarkdown.OptionalState} [defaultState]\n   *\n   * @returns {SimpleMarkdown.Parser}\n   *     The resulting parse function, with the following parameters:\n   *     @source: the input source string to be parsed\n   *     @state: an optional object to be threaded through parse\n   *         calls. Allows clients to add stateful operations to\n   *         parsing, such as keeping track of how many levels deep\n   *         some nesting is. For an example use-case, see passage-ref\n   *         parsing in src/widgets/passage/passage-markdown.jsx\n   */\n  var parserFor = function (rules /*: ParserRules */, defaultState /*: ?State */) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function (type) {\n      var rule = rules[type];\n      if (rule == null || rule.match == null) {\n        return false;\n      }\n      var order = rule.order;\n      if ((typeof order !== 'number' || !isFinite(order)) && typeof console !== 'undefined') {\n        console.warn(\"simple-markdown: Invalid order for rule `\" + type + \"`: \" + String(order));\n      }\n      return true;\n    });\n    ruleList.sort(function (typeA, typeB) {\n      var ruleA /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */rules[typeA] /*:: :any */;\n      var ruleB /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */rules[typeB] /*:: :any */;\n      var orderA = ruleA.order;\n      var orderB = ruleB.order;\n\n      // First sort based on increasing order\n      if (orderA !== orderB) {\n        return orderA - orderB;\n      }\n      var secondaryOrderA = ruleA.quality ? 0 : 1;\n      var secondaryOrderB = ruleB.quality ? 0 : 1;\n      if (secondaryOrderA !== secondaryOrderB) {\n        return secondaryOrderA - secondaryOrderB;\n\n        // Then based on increasing unicode lexicographic ordering\n      } else if (typeA < typeB) {\n        return -1;\n      } else if (typeA > typeB) {\n        return 1;\n      } else {\n        // Rules should never have the same name,\n        // but this is provided for completeness.\n        return 0;\n      }\n    });\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.Parser} */\n    var nestedParse = function (source /* : string */, state /* : ?State */) {\n      /** @type Array<SimpleMarkdown.SingleASTNode> */\n      var result = [];\n      state = state || latestState;\n      latestState = state;\n      while (source) {\n        // store the best match, it's rule, and quality:\n        var ruleType = null;\n        var rule = null;\n        var capture = null;\n        var quality = NaN;\n\n        // loop control variables:\n        var i = 0;\n        var currRuleType = ruleList[0];\n        var currRule /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */rules[currRuleType] /*:: :any */;\n        do {\n          var currOrder = currRule.order;\n          var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n          var currCapture = currRule.match(source, state, prevCaptureStr);\n          if (currCapture) {\n            var currQuality = currRule.quality ? currRule.quality(currCapture, state, prevCaptureStr) : 0;\n            // This should always be true the first time because\n            // the initial quality is NaN (that's why there's the\n            // condition negation).\n            if (!(currQuality <= quality)) {\n              ruleType = currRuleType;\n              rule = currRule;\n              capture = currCapture;\n              quality = currQuality;\n            }\n          }\n\n          // Move on to the next item.\n          // Note that this makes `currRule` be the next item\n          i++;\n          currRuleType = ruleList[i];\n          currRule = /*::((*/ /** @type {SimpleMarkdown.ParserRule} */rules[currRuleType] /*:: : any) : ParserRule)*/;\n        } while (\n        // keep looping while we're still within the ruleList\n        currRule && (\n        // if we don't have a match yet, continue\n        !capture ||\n        // or if we have a match, but the next rule is\n        // at the same order, and has a quality measurement\n        // functions, then this rule must have a quality\n        // measurement function (since they are sorted before\n        // those without), and we need to check if there is\n        // a better quality match\n        currRule.order === currOrder && currRule.quality));\n\n        // TODO(aria): Write tests for these\n        if (rule == null || capture == null /*:: || ruleType == null */) {\n          throw new Error(\"Could not find a matching rule for the below \" + \"content. The rule with highest `order` should \" + \"always match content provided to it. Check \" + \"the definition of `match` for '\" + ruleList[ruleList.length - 1] + \"'. It seems to not match the following source:\\n\" + source);\n        }\n        if (capture.index) {\n          // If present and non-zero, i.e. a non-^ regexp result:\n          throw new Error(\"`match` must return a capture starting at index 0 \" + \"(the current parse index). Did you forget a ^ at the \" + \"start of the RegExp?\");\n        }\n        var parsed = rule.parse(capture, nestedParse, state);\n        // We maintain the same object here so that rules can\n        // store references to the objects they return and\n        // modify them later. (oops sorry! but this adds a lot\n        // of power--see reflinks.)\n        if (Array.isArray(parsed)) {\n          Array.prototype.push.apply(result, parsed);\n        } else {\n          // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n          if (parsed.type == null) {\n            parsed.type = ruleType;\n          }\n          result.push( /** @type {SimpleMarkdown.SingleASTNode} */parsed);\n        }\n        state.prevCapture = capture;\n        source = source.substring(state.prevCapture[0].length);\n      }\n      return result;\n    };\n\n    /** @type {SimpleMarkdown.Parser} */\n    var outerParse = function (source /* : string */, state /* : ?State */) {\n      latestState = populateInitialState(state, defaultState);\n      if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n        source = source + \"\\n\\n\";\n      }\n      // We store the previous capture so that match functions can\n      // use some limited amount of lookbehind. Lists use this to\n      // ensure they don't match arbitrary '- ' or '* ' in inline\n      // text (see the list rule for more information). This stores\n      // the full regex capture object, if there is one.\n      latestState.prevCapture = null;\n      return nestedParse(preprocess(source), latestState);\n    };\n    return outerParse;\n  };\n\n  // Creates a match function for an inline scoped element from a regex\n  /** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\n  var inlineRegex = function (regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function (source, state) {\n      if (state.inline) {\n        return regex.exec(source);\n      } else {\n        return null;\n      }\n    };\n    match.regex = regex;\n    return match;\n  };\n\n  // Creates a match function for a block scoped element from a regex\n  /** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\n  var blockRegex = function (regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function (source, state) {\n      if (state.inline) {\n        return null;\n      } else {\n        return regex.exec(source);\n      }\n    };\n    match.regex = regex;\n    return match;\n  };\n\n  // Creates a match function from a regex, ignoring block/inline scope\n  /** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\n  var anyScopeRegex = function (regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function (source, state) {\n      return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n  };\n  var TYPE_SYMBOL = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\n  /**\n   * @param {string} type\n   * @param {string | number | null | undefined} key\n   * @param {Object<string, any>} props\n   * @returns {SimpleMarkdown.ReactElement}\n   */\n  var reactElement = function (type /* : string */, key /* : string | number | null | void */, props /* : { [string]: any } */) /* : ReactElement */{\n    var element /* : ReactElement */ = /** @type {SimpleMarkdown.ReactElement} */{\n      $$typeof: TYPE_SYMBOL,\n      type: type,\n      key: key == null ? undefined : key,\n      ref: null,\n      props: props,\n      _owner: null\n    } /* : any */;\n    return element;\n  };\n\n  /** Returns a closed HTML tag.\n   * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n   * @param {string} content - Inner content of tag\n   * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n   *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n   * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n   *   defaults to true\n   */\n  var htmlTag = function (tagName /* : string */, content /* : string */, attributes /* : ?{[any]: ?Attr} */, isClosed /* : ?boolean */) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n    var attributeString = \"\";\n    for (var attr in attributes) {\n      var attribute = attributes[attr];\n      // Removes falsey attributes\n      if (Object.prototype.hasOwnProperty.call(attributes, attr) && attribute) {\n        attributeString += \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n      }\n    }\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n    if (isClosed) {\n      return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n      return unclosedTag;\n    }\n  };\n  var EMPTY_PROPS = {};\n\n  /**\n   * @param {string | null | undefined} url - url to sanitize\n   * @returns {string | null} - url if safe, or null if a safe url could not be made\n   */\n  var sanitizeUrl = function (url /* : ?string */) {\n    if (url == null) {\n      return null;\n    }\n    try {\n      var prot = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '').toLowerCase();\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    } catch (e) {\n      // decodeURIComponent sometimes throws a URIError\n      // See `decodeURIComponent('a%AFc');`\n      // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n      return null;\n    }\n    return url;\n  };\n  var SANITIZE_TEXT_R = /[<>&\"']/g;\n  /** @type {any} */\n  var SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n  };\n  /**\n   * @param {SimpleMarkdown.Attr} text\n   * @returns {string}\n   */\n  var sanitizeText = function (text /* : Attr */) {\n    return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n      return SANITIZE_TEXT_CODES[chr];\n    });\n  };\n  var UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\n  /**\n   * @param {string} rawUrlString\n   * @returns {string}\n   */\n  var unescapeUrl = function (rawUrlString /* : string */) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n  };\n\n  /**\n   * Parse some content with the parser `parse`, with state.inline\n   * set to true. Useful for block elements; not generally necessary\n   * to be used by inline elements (where state.inline is already true.\n   *\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {string} content\n   * @param {SimpleMarkdown.State} state\n   * @returns {SimpleMarkdown.ASTNode}\n   */\n  var parseInline = function (parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n  };\n  /**\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {string} content\n   * @param {SimpleMarkdown.State} state\n   * @returns {SimpleMarkdown.ASTNode}\n   */\n  var parseBlock = function (parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n  };\n\n  /**\n   * @param {SimpleMarkdown.Capture} capture\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {SimpleMarkdown.State} state\n   * @returns {SimpleMarkdown.UnTypedASTNode}\n   */\n  var parseCaptureInline = function (capture, parse, state) {\n    return {\n      content: parseInline(parse, capture[1], state)\n    };\n  };\n  /**\n   * @returns {SimpleMarkdown.UnTypedASTNode}\n   */\n  var ignoreCapture = function () {\n    return {};\n  };\n\n  // recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\n  var LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n  // recognize the start of a list item:\n  // leading space plus a bullet plus a space (`   * `)\n  var LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\n  var LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n  // recognize an individual list item:\n  //  * hi\n  //    this is part of the same item\n  //\n  //    as is this, which is a new paragraph in the same item\n  //\n  //  * but this is not part of the same item\n  var LIST_ITEM_R = new RegExp(LIST_ITEM_PREFIX + \"[^\\\\n]*(?:\\\\n\" + \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\", \"gm\");\n  var BLOCK_END_R = /\\n{2,}$/;\n  var INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n  // recognize the end of a paragraph block inside a list item:\n  // two or more newlines at end end of the item\n  var LIST_BLOCK_END_R = BLOCK_END_R;\n  var LIST_ITEM_END_R = / *\\n+$/;\n  // check whether a list item has paragraphs: if it does,\n  // we leave the newlines at the end\n  var LIST_R = new RegExp(\"^( *)(\" + LIST_BULLET + \") \" + \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" + \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n  // the \\\\s*$ here is so that we can parse the inside of nested\n  // lists, where our content might end before we receive two `\\n`s\n  \"|\\\\s*\\n*$)\");\n  var LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n  var TABLES = function () {\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    /**\n     * @param {string} alignCapture\n     * @returns {SimpleMarkdown.TableAlignment}\n     */\n    var parseTableAlignCapture = function (alignCapture) {\n      if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n        return \"right\";\n      } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n        return \"center\";\n      } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n        return \"left\";\n      } else {\n        return null;\n      }\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {Array<SimpleMarkdown.TableAlignment>}\n     */\n    var parseTableAlign = function (source, parse, state, trimEndSeparators) {\n      if (trimEndSeparators) {\n        source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n      }\n      var alignText = source.trim().split(\"|\");\n      return alignText.map(parseTableAlignCapture);\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleASTNode[][]}\n     */\n    var parseTableRow = function (source, parse, state, trimEndSeparators) {\n      var prevInTable = state.inTable;\n      state.inTable = true;\n      var tableRow = parse(source.trim(), state);\n      state.inTable = prevInTable;\n\n      /** @type {SimpleMarkdown.SingleASTNode[][]} */\n      var cells = [[]];\n      tableRow.forEach(function (node, i) {\n        if (node.type === 'tableSeparator') {\n          // Filter out empty table separators at the start/end:\n          if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n            // Split the current row:\n            cells.push([]);\n          }\n        } else {\n          if (node.type === 'text' && (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')) {\n            node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n          }\n          cells[cells.length - 1].push(node);\n        }\n      });\n      return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function (source, parse, state, trimEndSeparators) {\n      var rowsText = source.trim().split(\"\\n\");\n      return rowsText.map(function (rowText) {\n        return parseTableRow(rowText, parse, state, trimEndSeparators);\n      });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function (trimEndSeparators) {\n      /** @type {SimpleMarkdown.SingleNodeParseFunction} */\n      return function (capture, parse, state) {\n        state.inline = true;\n        var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n        var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n        var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n        state.inline = false;\n        return {\n          type: \"table\",\n          header: header,\n          align: align,\n          cells: cells\n        };\n      };\n    };\n    return {\n      parseTable: parseTable(true),\n      parseNpTable: parseTable(false),\n      TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n      NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n  }();\n  var LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\n  var LINK_HREF_AND_TITLE = \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\n  var AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\n  /**\n   * @param {SimpleMarkdown.Capture} capture\n   * @param {SimpleMarkdown.State} state\n   * @param {SimpleMarkdown.RefNode} refNode\n   * @returns {SimpleMarkdown.RefNode}\n   */\n  var parseRef = function (capture, state, refNode /* : RefNode */) {\n    var ref = (capture[2] || capture[1]).replace(/\\s+/g, ' ').toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n      var def = state._defs[ref];\n      // `refNode` can be a link or an image. Both use\n      // target and title properties.\n      refNode.target = def.target;\n      refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n    return refNode;\n  };\n  var currOrder = 0;\n  /** @type {SimpleMarkdown.DefaultRules} */\n  var defaultRules /* : DefaultRules */ = {\n    Array: {\n      react: function (arr, output, state) {\n        var oldKey = state.key;\n        var result /* : Array<ReactElements> */ = [];\n\n        // map output over the ast, except group any text\n        // nodes together into a single string output.\n        for (var i = 0, key = 0; i < arr.length; i++, key++) {\n          // `key` is our numerical `state.key`, which we increment for\n          // every output node, but don't change for joined text nodes.\n          // (i, however, must change for joined text nodes)\n          state.key = '' + i;\n          var node = arr[i];\n          if (node.type === 'text') {\n            node = {\n              type: 'text',\n              content: node.content\n            };\n            for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n              node.content += arr[i + 1].content;\n            }\n          }\n          result.push(output(node, state));\n        }\n        state.key = oldKey;\n        return result;\n      },\n      html: function (arr, output, state) {\n        var result = \"\";\n\n        // map output over the ast, except group any text\n        // nodes together into a single string output.\n        for (var i = 0; i < arr.length; i++) {\n          var node = arr[i];\n          if (node.type === 'text') {\n            node = {\n              type: 'text',\n              content: node.content\n            };\n            for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n              node.content += arr[i + 1].content;\n            }\n          }\n          result += output(node, state);\n        }\n        return result;\n      }\n    },\n    heading: {\n      order: currOrder++,\n      match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n      parse: function (capture, parse, state) {\n        return {\n          level: capture[1].length,\n          content: parseInline(parse, capture[2].trim(), state)\n        };\n      },\n      react: function (node, output, state) {\n        return reactElement('h' + node.level, state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        return htmlTag(\"h\" + node.level, output(node.content, state));\n      }\n    },\n    nptable: {\n      order: currOrder++,\n      match: blockRegex(TABLES.NPTABLE_REGEX),\n      parse: TABLES.parseNpTable,\n      react: null,\n      html: null\n    },\n    lheading: {\n      order: currOrder++,\n      match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n      parse: function (capture, parse, state) {\n        return {\n          type: \"heading\",\n          level: capture[2] === '=' ? 1 : 2,\n          content: parseInline(parse, capture[1], state)\n        };\n      },\n      react: null,\n      html: null\n    },\n    hr: {\n      order: currOrder++,\n      match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n      parse: ignoreCapture,\n      react: function (node, output, state) {\n        return reactElement('hr', state.key, EMPTY_PROPS);\n      },\n      html: function (node, output, state) {\n        return \"<hr>\";\n      }\n    },\n    codeBlock: {\n      order: currOrder++,\n      match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n      parse: function (capture, parse, state) {\n        var content = capture[0].replace(/^    /gm, '').replace(/\\n+$/, '');\n        return {\n          lang: undefined,\n          content: content\n        };\n      },\n      react: function (node, output, state) {\n        var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n        return reactElement('pre', state.key, {\n          children: reactElement('code', null, {\n            className: className,\n            children: node.content\n          })\n        });\n      },\n      html: function (node, output, state) {\n        var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n        var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n          class: className\n        });\n        return htmlTag(\"pre\", codeBlock);\n      }\n    },\n    fence: {\n      order: currOrder++,\n      match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n      parse: function (capture, parse, state) {\n        return {\n          type: \"codeBlock\",\n          lang: capture[2] || undefined,\n          content: capture[3]\n        };\n      },\n      react: null,\n      html: null\n    },\n    blockQuote: {\n      order: currOrder++,\n      match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n      parse: function (capture, parse, state) {\n        var content = capture[0].replace(/^ *> ?/gm, '');\n        return {\n          content: parse(content, state)\n        };\n      },\n      react: function (node, output, state) {\n        return reactElement('blockquote', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        return htmlTag(\"blockquote\", output(node.content, state));\n      }\n    },\n    list: {\n      order: currOrder++,\n      match: function (source, state) {\n        // We only want to break into a list if we are at the start of a\n        // line. This is to avoid parsing \"hi * there\" with \"* there\"\n        // becoming a part of a list.\n        // You might wonder, \"but that's inline, so of course it wouldn't\n        // start a list?\". You would be correct! Except that some of our\n        // lists can be inline, because they might be inside another list,\n        // in which case we can parse with inline scope, but need to allow\n        // nested lists inside this inline scope.\n        var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n        var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n        var isListBlock = state._list || !state.inline;\n        if (isStartOfLineCapture && isListBlock) {\n          source = isStartOfLineCapture[1] + source;\n          return LIST_R.exec(source);\n        } else {\n          return null;\n        }\n      },\n      parse: function (capture, parse, state) {\n        var bullet = capture[2];\n        var ordered = bullet.length > 1;\n        var start = ordered ? +bullet : undefined;\n        var items = /** @type {string[]} */\n        capture[0].replace(LIST_BLOCK_END_R, \"\\n\").match(LIST_ITEM_R);\n\n        // We know this will match here, because of how the regexes are\n        // defined\n        /*:: items = ((items : any) : Array<string>) */\n\n        var lastItemWasAParagraph = false;\n        var itemContent = items.map(function ( /** @type {string} */item, /** @type {number} */i) {\n          // We need to see how far indented this item is:\n          var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n          var space = prefixCapture ? prefixCapture[0].length : 0;\n          // And then we construct a regex to \"unindent\" the subsequent\n          // lines of the items by that amount:\n          var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n          // Before processing the item, we need a couple things\n          var content = item\n          // remove indents on trailing lines:\n          .replace(spaceRegex, '')\n          // remove the bullet:\n          .replace(LIST_ITEM_PREFIX_R, '');\n\n          // I'm not sur4 why this is necessary again?\n          /*:: items = ((items : any) : Array<string>) */\n\n          // Handling \"loose\" lists, like:\n          //\n          //  * this is wrapped in a paragraph\n          //\n          //  * as is this\n          //\n          //  * as is this\n          var isLastItem = i === items.length - 1;\n          var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n          // Any element in a list is a block if it contains multiple\n          // newlines. The last element in the list can also be a block\n          // if the previous item in the list was a block (this is\n          // because non-last items in the list can end with \\n\\n, but\n          // the last item can't, so we just \"inherit\" this property\n          // from our previous element).\n          var thisItemIsAParagraph = containsBlocks || isLastItem && lastItemWasAParagraph;\n          lastItemWasAParagraph = thisItemIsAParagraph;\n\n          // backup our state for restoration afterwards. We're going to\n          // want to set state._list to true, and state.inline depending\n          // on our list's looseness.\n          var oldStateInline = state.inline;\n          var oldStateList = state._list;\n          state._list = true;\n\n          // Parse inline if we're in a tight list, or block if we're in\n          // a loose list.\n          var adjustedContent;\n          if (thisItemIsAParagraph) {\n            state.inline = false;\n            adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n          } else {\n            state.inline = true;\n            adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n          }\n          var result = parse(adjustedContent, state);\n\n          // Restore our state before returning\n          state.inline = oldStateInline;\n          state._list = oldStateList;\n          return result;\n        });\n        return {\n          ordered: ordered,\n          start: start,\n          items: itemContent\n        };\n      },\n      react: function (node, output, state) {\n        var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n        return reactElement(ListWrapper, state.key, {\n          start: node.start,\n          children: node.items.map(function ( /** @type {SimpleMarkdown.ASTNode} */item, /** @type {number} */i) {\n            return reactElement('li', '' + i, {\n              children: output(item, state)\n            });\n          })\n        });\n      },\n      html: function (node, output, state) {\n        var listItems = node.items.map(function ( /** @type {SimpleMarkdown.ASTNode} */item) {\n          return htmlTag(\"li\", output(item, state));\n        }).join(\"\");\n        var listTag = node.ordered ? \"ol\" : \"ul\";\n        var attributes = {\n          start: node.start\n        };\n        return htmlTag(listTag, listItems, attributes);\n      }\n    },\n    def: {\n      order: currOrder++,\n      // TODO(aria): This will match without a blank line before the next\n      // block element, which is inconsistent with most of the rest of\n      // simple-markdown.\n      match: blockRegex(/^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/),\n      parse: function (capture, parse, state) {\n        var def = capture[1].replace(/\\s+/g, ' ').toLowerCase();\n        var target = capture[2];\n        var title = capture[3];\n\n        // Look for previous links/images using this def\n        // If any links/images using this def have already been declared,\n        // they will have added themselves to the state._refs[def] list\n        // (_ to deconflict with client-defined state). We look through\n        // that list of reflinks for this def, and modify those AST nodes\n        // with our newly found information now.\n        // Sorry :(.\n        if (state._refs && state._refs[def]) {\n          // `refNode` can be a link or an image\n          state._refs[def].forEach(function ( /** @type {SimpleMarkdown.RefNode} */refNode) {\n            refNode.target = target;\n            refNode.title = title;\n          });\n        }\n\n        // Add this def to our map of defs for any future links/images\n        // In case we haven't found any or all of the refs referring to\n        // this def yet, we add our def to the table of known defs, so\n        // that future reflinks can modify themselves appropriately with\n        // this information.\n        state._defs = state._defs || {};\n        state._defs[def] = {\n          target: target,\n          title: title\n        };\n\n        // return the relevant parsed information\n        // for debugging only.\n        return {\n          def: def,\n          target: target,\n          title: title\n        };\n      },\n      react: function () {\n        return null;\n      },\n      html: function () {\n        return \"\";\n      }\n    },\n    table: {\n      order: currOrder++,\n      match: blockRegex(TABLES.TABLE_REGEX),\n      parse: TABLES.parseTable,\n      react: function (node, output, state) {\n        /**\n         * @param {number} colIndex\n         * @returns {{ [attr: string]: SimpleMarkdown.Attr }}\n         */\n        var getStyle = function (colIndex) {\n          return node.align[colIndex] == null ? {} : {\n            textAlign: node.align[colIndex]\n          };\n        };\n        var headers = node.header.map(function ( /** @type {SimpleMarkdown.ASTNode} */content, /** @type {number} */i) {\n          return reactElement('th', '' + i, {\n            style: getStyle(i),\n            scope: 'col',\n            children: output(content, state)\n          });\n        });\n        var rows = node.cells.map(function ( /** @type {SimpleMarkdown.ASTNode[]} */row, /** @type {number} */r) {\n          return reactElement('tr', '' + r, {\n            children: row.map(function ( /** @type {SimpleMarkdown.ASTNode} */content, /** @type {number} */c) {\n              return reactElement('td', '' + c, {\n                style: getStyle(c),\n                children: output(content, state)\n              });\n            })\n          });\n        });\n        return reactElement('table', state.key, {\n          children: [reactElement('thead', 'thead', {\n            children: reactElement('tr', null, {\n              children: headers\n            })\n          }), reactElement('tbody', 'tbody', {\n            children: rows\n          })]\n        });\n      },\n      html: function (node, output, state) {\n        /**\n         * @param {number} colIndex\n         * @returns {string}\n         */\n        var getStyle = function (colIndex) {\n          return node.align[colIndex] == null ? \"\" : \"text-align:\" + node.align[colIndex] + \";\";\n        };\n        var headers = node.header.map(function ( /** @type {SimpleMarkdown.ASTNode} */content, /** @type {number} */i) {\n          return htmlTag(\"th\", output(content, state), {\n            style: getStyle(i),\n            scope: \"col\"\n          });\n        }).join(\"\");\n        var rows = node.cells.map(function ( /** @type {SimpleMarkdown.ASTNode[]} */row) {\n          var cols = row.map(function ( /** @type {SimpleMarkdown.ASTNode} */content, /** @type {number} */c) {\n            return htmlTag(\"td\", output(content, state), {\n              style: getStyle(c)\n            });\n          }).join(\"\");\n          return htmlTag(\"tr\", cols);\n        }).join(\"\");\n        var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n        var tbody = htmlTag(\"tbody\", rows);\n        return htmlTag(\"table\", thead + tbody);\n      }\n    },\n    newline: {\n      order: currOrder++,\n      match: blockRegex(/^(?:\\n *)*\\n/),\n      parse: ignoreCapture,\n      react: function (node, output, state) {\n        return \"\\n\";\n      },\n      html: function (node, output, state) {\n        return \"\\n\";\n      }\n    },\n    paragraph: {\n      order: currOrder++,\n      match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n      parse: parseCaptureInline,\n      react: function (node, output, state) {\n        return reactElement('div', state.key, {\n          className: 'paragraph',\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        var attributes = {\n          class: 'paragraph'\n        };\n        return htmlTag(\"div\", output(node.content, state), attributes);\n      }\n    },\n    escape: {\n      order: currOrder++,\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n      parse: function (capture, parse, state) {\n        return {\n          type: \"text\",\n          content: capture[1]\n        };\n      },\n      react: null,\n      html: null\n    },\n    tableSeparator: {\n      order: currOrder++,\n      match: function (source, state) {\n        if (!state.inTable) {\n          return null;\n        }\n        return /^ *\\| */.exec(source);\n      },\n      parse: function () {\n        return {\n          type: 'tableSeparator'\n        };\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      react: function () {\n        return ' | ';\n      },\n      html: function () {\n        return ' &vert; ';\n      }\n    },\n    autolink: {\n      order: currOrder++,\n      match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n      parse: function (capture, parse, state) {\n        return {\n          type: \"link\",\n          content: [{\n            type: \"text\",\n            content: capture[1]\n          }],\n          target: capture[1]\n        };\n      },\n      react: null,\n      html: null\n    },\n    mailto: {\n      order: currOrder++,\n      match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n      parse: function (capture, parse, state) {\n        var address = capture[1];\n        var target = capture[1];\n\n        // Check for a `mailto:` already existing in the link:\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = \"mailto:\" + target;\n        }\n        return {\n          type: \"link\",\n          content: [{\n            type: \"text\",\n            content: address\n          }],\n          target: target\n        };\n      },\n      react: null,\n      html: null\n    },\n    url: {\n      order: currOrder++,\n      match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n      parse: function (capture, parse, state) {\n        return {\n          type: \"link\",\n          content: [{\n            type: \"text\",\n            content: capture[1]\n          }],\n          target: capture[1],\n          title: undefined\n        };\n      },\n      react: null,\n      html: null\n    },\n    link: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp(\"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n      parse: function (capture, parse, state) {\n        var link = {\n          content: parse(capture[1], state),\n          target: unescapeUrl(capture[2]),\n          title: capture[3]\n        };\n        return link;\n      },\n      react: function (node, output, state) {\n        return reactElement('a', state.key, {\n          href: sanitizeUrl(node.target),\n          title: node.title,\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        var attributes = {\n          href: sanitizeUrl(node.target),\n          title: node.title\n        };\n        return htmlTag(\"a\", output(node.content, state), attributes);\n      }\n    },\n    image: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp(\"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n      parse: function (capture, parse, state) {\n        var image = {\n          alt: capture[1],\n          target: unescapeUrl(capture[2]),\n          title: capture[3]\n        };\n        return image;\n      },\n      react: function (node, output, state) {\n        return reactElement('img', state.key, {\n          src: sanitizeUrl(node.target),\n          alt: node.alt,\n          title: node.title\n        });\n      },\n      html: function (node, output, state) {\n        var attributes = {\n          src: sanitizeUrl(node.target),\n          alt: node.alt,\n          title: node.title\n        };\n        return htmlTag(\"img\", \"\", attributes, false);\n      }\n    },\n    reflink: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp(\n      // The first [part] of the link\n      \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n      // The [ref] target of the link\n      \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n      parse: function (capture, parse, state) {\n        return parseRef(capture, state, {\n          type: \"link\",\n          content: parse(capture[1], state)\n        });\n      },\n      react: null,\n      html: null\n    },\n    refimage: {\n      order: currOrder++,\n      match: inlineRegex(new RegExp(\n      // The first [part] of the link\n      \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n      // The [ref] target of the link\n      \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n      parse: function (capture, parse, state) {\n        return parseRef(capture, state, {\n          type: \"image\",\n          alt: capture[1]\n        });\n      },\n      react: null,\n      html: null\n    },\n    em: {\n      order: currOrder /* same as strong/u */,\n      match: inlineRegex(new RegExp(\n      // only match _s surrounding words.\n      \"^\\\\b_\" + \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" + \"\\\\b\" +\n      // Or match *s:\n      \"|\" +\n      // Only match *s that are followed by a non-space:\n      \"^\\\\*(?=\\\\S)(\" +\n      // Match at least one of:\n      \"(?:\" +\n      //  - `**`: so that bolds inside italics don't close the\n      //          italics\n      \"\\\\*\\\\*|\" +\n      //  - escape sequence: so escaped *s don't close us\n      \"\\\\\\\\[\\\\s\\\\S]|\" +\n      //  - whitespace: followed by a non-* (we don't\n      //          want ' *' to close an italics--it might\n      //          start a list)\n      \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n      //  - non-whitespace, non-*, non-backslash characters\n      \"[^\\\\s\\\\*\\\\\\\\]\" + \")+?\" +\n      // followed by a non-space, non-* then *\n      \")\\\\*(?!\\\\*)\")),\n      quality: function (capture) {\n        // precedence by length, `em` wins ties:\n        return capture[0].length + 0.2;\n      },\n      parse: function (capture, parse, state) {\n        return {\n          content: parse(capture[2] || capture[1], state)\n        };\n      },\n      react: function (node, output, state) {\n        return reactElement('em', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        return htmlTag(\"em\", output(node.content, state));\n      }\n    },\n    strong: {\n      order: currOrder /* same as em */,\n      match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n      quality: function (capture) {\n        // precedence by length, wins ties vs `u`:\n        return capture[0].length + 0.1;\n      },\n      parse: parseCaptureInline,\n      react: function (node, output, state) {\n        return reactElement('strong', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        return htmlTag(\"strong\", output(node.content, state));\n      }\n    },\n    u: {\n      order: currOrder++ /* same as em&strong; increment for next rule */,\n      match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n      quality: function (capture) {\n        // precedence by length, loses all ties\n        return capture[0].length;\n      },\n      parse: parseCaptureInline,\n      react: function (node, output, state) {\n        return reactElement('u', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        return htmlTag(\"u\", output(node.content, state));\n      }\n    },\n    del: {\n      order: currOrder++,\n      match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n      parse: parseCaptureInline,\n      react: function (node, output, state) {\n        return reactElement('del', state.key, {\n          children: output(node.content, state)\n        });\n      },\n      html: function (node, output, state) {\n        return htmlTag(\"del\", output(node.content, state));\n      }\n    },\n    inlineCode: {\n      order: currOrder++,\n      match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n      parse: function (capture, parse, state) {\n        return {\n          content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n        };\n      },\n      react: function (node, output, state) {\n        return reactElement('code', state.key, {\n          children: node.content\n        });\n      },\n      html: function (node, output, state) {\n        return htmlTag(\"code\", sanitizeText(node.content));\n      }\n    },\n    br: {\n      order: currOrder++,\n      match: anyScopeRegex(/^ {2,}\\n/),\n      parse: ignoreCapture,\n      react: function (node, output, state) {\n        return reactElement('br', state.key, EMPTY_PROPS);\n      },\n      html: function (node, output, state) {\n        return \"<br>\";\n      }\n    },\n    text: {\n      order: currOrder++,\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      match: anyScopeRegex(/^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/),\n      parse: function (capture, parse, state) {\n        return {\n          content: capture[0]\n        };\n      },\n      react: function (node, output, state) {\n        return node.content;\n      },\n      html: function (node, output, state) {\n        return sanitizeText(node.content);\n      }\n    }\n  };\n\n  /** (deprecated)\n   * @param {any} rules\n   * @param {any} property\n   * @returns {any}\n   */\n  var ruleOutput = function /* :: <Rule : Object> */\n  (rules /* : OutputRules<Rule> */, property /* : $Keys<Rule> */) {\n    if (!property && typeof console !== \"undefined\") {\n      console.warn(\"simple-markdown ruleOutput should take 'react' or \" + \"'html' as the second argument.\");\n    }\n\n    /** @type {SimpleMarkdown.NodeOutput<any>} */\n    var nestedRuleOutput /* : NodeOutput<any> */ = function (ast /* : SingleASTNode */, outputFunc /* : Output<any> */, state /* : State */) {\n      return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n  };\n\n  /** (deprecated)\n   * @param {any} outputFunc\n   * @returns {any}\n   */\n  var reactFor = function (outputFunc /* : ReactNodeOutput */) /* : ReactOutput */{\n    /** @type {SimpleMarkdown.ReactOutput} */\n    var nestedOutput /* : ReactOutput */ = function (ast, state) {\n      state = state || {};\n      if (Array.isArray(ast)) {\n        var oldKey = state.key;\n        var result /* : Array<ReactElements> */ = [];\n\n        // map nestedOutput over the ast, except group any text\n        // nodes together into a single string output.\n        var lastResult = null;\n        for (var i = 0; i < ast.length; i++) {\n          state.key = '' + i;\n          var nodeOut = nestedOutput(ast[i], state);\n          if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n            lastResult = lastResult + nodeOut;\n            result[result.length - 1] = lastResult;\n          } else {\n            result.push(nodeOut);\n            lastResult = nodeOut;\n          }\n        }\n        state.key = oldKey;\n        return result;\n      } else {\n        return outputFunc(ast, nestedOutput, state);\n      }\n    };\n    return nestedOutput;\n  };\n\n  /** (deprecated)\n   * @param {any} outputFunc\n   * @returns {any}\n   */\n  var htmlFor = function (outputFunc /* : HtmlNodeOutput */) /* : HtmlOutput */{\n    /** @type {SimpleMarkdown.HtmlOutput} */\n    var nestedOutput /* : HtmlOutput */ = function (ast, state) {\n      state = state || {};\n      if (Array.isArray(ast)) {\n        return ast.map(function (node) {\n          return nestedOutput(node, state);\n        }).join(\"\");\n      } else {\n        return outputFunc(ast, nestedOutput, state);\n      }\n    };\n    return nestedOutput;\n  };\n\n  /**\n   * @type {SimpleMarkdown.OutputFor}\n   */\n  var outputFor = function /* :: <Rule : Object> */\n  (rules /* : OutputRules<Rule> */, property /* : $Keys<Rule> */, defaultState /* : ?State */) {\n    if (!property) {\n      throw new Error('simple-markdown: outputFor: `property` must be ' + 'defined. ' + 'if you just upgraded, you probably need to replace `outputFor` ' + 'with `reactFor`');\n    }\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.ArrayRule} */\n    var arrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n      throw new Error('simple-markdown: outputFor: to join nodes of type `' + property + '` you must provide an `Array:` joiner rule with that type, ' + 'Please see the docs for details on specifying an Array rule.');\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var nestedOutput /* : Output<any> */ = function (ast, state) {\n      state = state || latestState;\n      latestState = state;\n      if (Array.isArray(ast)) {\n        return arrayRuleOutput(ast, nestedOutput, state);\n      } else {\n        return rules[ast.type][property](ast, nestedOutput, state);\n      }\n    };\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var outerOutput = function (ast, state) {\n      latestState = populateInitialState(state, defaultState);\n      return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n  };\n  var defaultRawParse = parserFor(defaultRules);\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {Array<SimpleMarkdown.SingleASTNode>}\n   */\n  var defaultBlockParse = function (source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {Array<SimpleMarkdown.SingleASTNode>}\n   */\n  var defaultInlineParse = function (source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {Array<SimpleMarkdown.SingleASTNode>}\n   */\n  var defaultImplicitParse = function (source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n  };\n\n  /** @type {SimpleMarkdown.ReactOutput} */\n  var defaultReactOutput /* : ReactOutput */ = outputFor(defaultRules, \"react\");\n  /** @type {SimpleMarkdown.HtmlOutput} */\n  var defaultHtmlOutput /* : HtmlOutput */ = outputFor(defaultRules, \"html\");\n\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {SimpleMarkdown.ReactElements}\n   */\n  var markdownToReact = function (source, state) /* : ReactElements */{\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.OptionalState} [state]\n   * @returns {string}\n   */\n  var markdownToHtml = function (source, state) /* : string */{\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n  };\n\n  /**\n   * @param {SimpleMarkdown.ReactMarkdownProps} props\n   * @returns {SimpleMarkdown.ReactElement}\n   */\n  var ReactMarkdown = function (props) {\n    /** @type {Object} */\n    var divProps = {};\n    for (var prop in props) {\n      if (prop !== 'source' && Object.prototype.hasOwnProperty.call(props, prop)) {\n        divProps[prop] = props[prop];\n      }\n    }\n    divProps.children = markdownToReact(props.source);\n    return reactElement('div', null, divProps);\n  };\n\n  /*:: // Flow exports:\n  type Exports = {\n      +defaultRules: DefaultRules,\n      +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n      +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n  \n      +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n      +reactFor: (ReactNodeOutput) => ReactOutput,\n      +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n  \n      +inlineRegex: (regex: RegExp) => MatchFunction,\n      +blockRegex: (regex: RegExp) => MatchFunction,\n      +anyScopeRegex: (regex: RegExp) => MatchFunction,\n      +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n      +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n  \n      +markdownToReact: (source: string, state?: ?State) => ReactElements,\n      +markdownToHtml: (source: string, state?: ?State) => string,\n      +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n  \n      +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n      +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n      +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n      +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n  \n      +defaultReactOutput: ReactOutput,\n      +defaultHtmlOutput: HtmlOutput,\n  \n      +preprocess: (source: string) => string,\n      +sanitizeText: (text: Attr) => string,\n      +sanitizeUrl: (url: ?string) => ?string,\n      +unescapeUrl: (url: string) => string,\n      +htmlTag: (tagName: string, content: string, attributes: ?{ [any]: ?Attr }, isClosed: ?boolean) => string,\n      +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n  };\n  \n  export type {\n      // Hopefully you shouldn't have to use these, but they're here if you need!\n      // Top-level API:\n      State,\n      Parser,\n      Output,\n      ReactOutput,\n      HtmlOutput,\n  \n      // Most of the following types should be considered experimental and\n      // subject to change or change names. Again, they shouldn't be necessary,\n      // but if they are I'd love to hear how so I can better support them!\n  \n      // Individual Rule fields:\n      Capture,\n      MatchFunction,\n      ParseFunction,\n      NodeOutput,\n      ArrayNodeOutput,\n      ReactNodeOutput,\n  \n      // Single rules:\n      ParserRule,\n      ReactOutputRule,\n      HtmlOutputRule,\n  \n      // Sets of rules:\n      ParserRules,\n      OutputRules,\n      Rules,\n      ReactRules,\n      HtmlRules,\n  };\n  */\n\n  var SimpleMarkdown /* : Exports */ = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n    defaultParse: function () {\n      if (typeof console !== 'undefined') {\n        console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n      }\n      return defaultImplicitParse.apply(null, /** @type {any} */arguments);\n    },\n    defaultOutput: function () {\n      if (typeof console !== 'undefined') {\n        console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n      }\n      return defaultReactOutput.apply(null, /** @type {any} */arguments);\n    }\n  };\n  return SimpleMarkdown;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","SimpleMarkdown","CR_NEWLINE_R","TAB_R","FORMFEED_R","preprocess","source","replace","populateInitialState","givenState","defaultState","state","prop","Object","prototype","hasOwnProperty","call","parserFor","rules","ruleList","keys","filter","type","rule","match","order","isFinite","console","warn","String","sort","typeA","typeB","ruleA","ruleB","orderA","orderB","secondaryOrderA","quality","secondaryOrderB","latestState","nestedParse","result","ruleType","capture","NaN","i","currRuleType","currRule","currOrder","prevCaptureStr","prevCapture","currCapture","currQuality","Error","length","index","parsed","parse","Array","isArray","push","apply","substring","outerParse","inline","disableAutoBlockNewlines","inlineRegex","regex","exec","blockRegex","anyScopeRegex","TYPE_SYMBOL","Symbol","for","reactElement","key","props","element","$$typeof","undefined","ref","_owner","htmlTag","tagName","content","attributes","isClosed","attributeString","attr","attribute","sanitizeText","unclosedTag","EMPTY_PROPS","sanitizeUrl","url","prot","decodeURIComponent","toLowerCase","indexOf","e","SANITIZE_TEXT_R","SANITIZE_TEXT_CODES","text","chr","UNESCAPE_URL_R","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","parseBlock","parseCaptureInline","ignoreCapture","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","RegExp","LIST_ITEM_R","BLOCK_END_R","INLINE_CODE_ESCAPE_BACKTICKS_R","LIST_BLOCK_END_R","LIST_ITEM_END_R","LIST_R","LIST_LOOKBEHIND_R","TABLES","TABLE_ROW_SEPARATOR_TRIM","TABLE_CELL_END_TRIM","TABLE_RIGHT_ALIGN","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","parseTableAlignCapture","alignCapture","test","parseTableAlign","trimEndSeparators","alignText","trim","split","map","parseTableRow","prevInTable","inTable","tableRow","cells","forEach","node","parseTableCells","rowsText","rowText","parseTable","header","align","parseNpTable","TABLE_REGEX","NPTABLE_REGEX","LINK_INSIDE","LINK_HREF_AND_TITLE","AUTOLINK_MAILTO_CHECK_R","parseRef","refNode","_defs","def","target","title","_refs","defaultRules","react","arr","output","oldKey","html","heading","level","children","nptable","lheading","hr","codeBlock","lang","className","class","fence","blockQuote","list","isStartOfLineCapture","isListBlock","_list","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","item","prefixCapture","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","ListWrapper","listItems","join","listTag","table","getStyle","colIndex","textAlign","headers","style","scope","rows","row","r","c","cols","thead","tbody","newline","paragraph","escape","tableSeparator","autolink","mailto","address","link","href","image","alt","src","reflink","refimage","em","strong","u","del","inlineCode","br","ruleOutput","property","nestedRuleOutput","ast","outputFunc","reactFor","nestedOutput","lastResult","nodeOut","htmlFor","outputFor","arrayRule","arrayRuleCheck","arrayRuleOutput","outerOutput","defaultRawParse","defaultBlockParse","defaultInlineParse","defaultImplicitParse","isBlock","defaultReactOutput","defaultHtmlOutput","markdownToReact","markdownToHtml","ReactMarkdown","divProps","defaultParse","arguments","defaultOutput"],"sources":["/Users/nickbaumann/Develop/mini-design-sprint/node_modules/simple-markdown/simple-markdown.js"],"sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = global || self, global.SimpleMarkdown = factory());\n}(this, (function () { 'use strict';\n\n/* @flow */\n/* @ts-check */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n *\n * LICENSE (MIT):\n * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n *\n * Portions adapted from marked.js copyright (c) 2011-2014\n * Christopher Jeffrey (https://github.com/chjj/).\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n// Typescript language & simple-markdown.d.ts references:\n/// <reference lib=\"ES2018\" />\n/// <reference path=\"../simple-markdown.d.ts\" />\n\n/*::\n// Flow Type Definitions:\n\ntype Capture =\n    Array<string> & {index: number} |\n    Array<string> & {index?: number};\n\ntype Attr = string | number | boolean | null | void;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {\n    key?: string | number | void,\n    inline?: ?boolean,\n    [string]: any,\n};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = { regex?: RegExp } & (\n    source: string,\n    state: State,\n    prevCapture: string\n) => ?Capture;\n\ntype Parser = (\n    source: string,\n    state?: ?State\n) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => (UnTypedASTNode | ASTNode);\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (\n    node: ASTNode,\n    state?: ?State\n) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n};\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +tableSeparator: DefaultInRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n    alt?: string,\n};\n\n// End Flow Definitions\n*/\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n\n/**\n * Turn various whitespace into easy-to-process whitespace\n * @param {string} source\n * @returns {string}\n */\nvar preprocess = function(source /* : string */) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n            .replace(FORMFEED_R, '')\n            .replace(TAB_R, '    ');\n};\n\n/**\n * @param {SimpleMarkdown.OptionalState} givenState\n * @param {SimpleMarkdown.OptionalState} defaultState\n * @returns {SimpleMarkdown.State}\n */\nvar populateInitialState = function(\n    givenState /* : ?State */,\n    defaultState /* : ?State */\n) /* : State */{\n    var state /* : State */ = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function(rules /*: ParserRules */, defaultState /*: ?State */) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function(type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if ((typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined') {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" + type + \"`: \" +\n                String(order)\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function(typeA, typeB) {\n        var ruleA /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeA] /*:: :any */);\n        var ruleB /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ (rules[typeB] /*:: :any */);\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.Parser} */\n    var nestedParse = function(source /* : string */, state /* : ?State */) {\n        /** @type Array<SimpleMarkdown.SingleASTNode> */\n        var result = [];\n        state = state || latestState;\n        latestState = state;\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n            var currRule /* : ParserRule */ = /** @type {SimpleMarkdown.ParserRule} */ ( rules[currRuleType] /*:: :any */ );\n\n            do {\n                var currOrder = currRule.order;\n                var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n                var currCapture = currRule.match(source, state, prevCaptureStr);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality ? currRule.quality(\n                        currCapture,\n                        state,\n                        prevCaptureStr\n                    ) : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                currRule = /*::((*/ /** @type {SimpleMarkdown.ParserRule} */ (rules[currRuleType]) /*:: : any) : ParserRule)*/;\n\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule && (\n                    // if we don't have a match yet, continue\n                    !capture || (\n                        // or if we have a match, but the next rule is\n                        // at the same order, and has a quality measurement\n                        // functions, then this rule must have a quality\n                        // measurement function (since they are sorted before\n                        // those without), and we need to check if there is\n                        // a better quality match\n                        currRule.order === currOrder &&\n                        currRule.quality\n                    )\n                )\n            );\n\n            // TODO(aria): Write tests for these\n            if (rule == null || capture == null /*:: || ruleType == null */) {\n                throw new Error(\n                    \"Could not find a matching rule for the below \" +\n                    \"content. The rule with highest `order` should \" +\n                    \"always match content provided to it. Check \" +\n                    \"the definition of `match` for '\" +\n                    ruleList[ruleList.length - 1] +\n                    \"'. It seems to not match the following source:\\n\" +\n                    source\n                );\n            }\n            if (capture.index) { // If present and non-zero, i.e. a non-^ regexp result:\n                throw new Error(\n                    \"`match` must return a capture starting at index 0 \" +\n                    \"(the current parse index). Did you forget a ^ at the \" +\n                    \"start of the RegExp?\"\n                );\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    parsed.type = ruleType;\n                }\n                result.push(/** @type {SimpleMarkdown.SingleASTNode} */ (parsed));\n            }\n\n            state.prevCapture = capture;\n            source = source.substring(state.prevCapture[0].length);\n        }\n        return result;\n    };\n\n    /** @type {SimpleMarkdown.Parser} */\n    var outerParse = function(source /* : string */, state /* : ?State */) {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information). This stores\n        // the full regex capture object, if there is one.\n        latestState.prevCapture = null;\n        return nestedParse(preprocess(source), latestState);\n    };\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar inlineRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar blockRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\n/** @type {(regex: RegExp) => SimpleMarkdown.MatchFunction} */\nvar anyScopeRegex = function(regex /* : RegExp */) {\n    /** @type {SimpleMarkdown.MatchFunction} */\n    var match /* : MatchFunction */ = function(source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === 'function' && Symbol.for &&\n     Symbol.for('react.element')) ||\n    0xeac7;\n\n/**\n * @param {string} type\n * @param {string | number | null | undefined} key\n * @param {Object<string, any>} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar reactElement = function(\n    type /* : string */,\n    key /* : string | number | null | void */,\n    props /* : { [string]: any } */\n) /* : ReactElement */ {\n    var element /* : ReactElement */ = /** @type {SimpleMarkdown.ReactElement} */ ({\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key == null ? undefined : key,\n        ref: null,\n        props: props,\n        _owner: null\n    } /* : any */);\n    return element;\n};\n\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\nvar htmlTag = function(\n    tagName /* : string */,\n    content /* : string */,\n    attributes /* : ?{[any]: ?Attr} */,\n    isClosed /* : ?boolean */\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (Object.prototype.hasOwnProperty.call(attributes, attr) &&\n                attribute) {\n            attributeString += \" \" +\n                sanitizeText(attr) + '=\"' +\n                sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\nvar sanitizeUrl = function(url /* : ?string */) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\n/** @type {any} */\nvar SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n};\n/**\n * @param {SimpleMarkdown.Attr} text\n * @returns {string}\n */\nvar sanitizeText = function(text /* : Attr */) {\n    return String(text).replace(SANITIZE_TEXT_R, function(chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\n/**\n * @param {string} rawUrlString\n * @returns {string}\n */\nvar unescapeUrl = function(rawUrlString /* : string */) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n *\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseInline = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n/**\n * @param {SimpleMarkdown.Parser} parse\n * @param {string} content\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.ASTNode}\n */\nvar parseBlock = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.Parser} parse\n * @param {SimpleMarkdown.State} state\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar parseCaptureInline = function(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state)\n    };\n};\n/**\n * @returns {SimpleMarkdown.UnTypedASTNode}\n */\nvar ignoreCapture = function() { return {}; };\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    \"[^\\\\n]*(?:\\\\n\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\"\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" + LIST_BULLET + \") \" +\n    \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    \"|\\\\s*\\n*$)\"\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function() {\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    /**\n     * @param {string} alignCapture\n     * @returns {SimpleMarkdown.TableAlignment}\n     */\n    var parseTableAlignCapture = function(alignCapture) {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {Array<SimpleMarkdown.TableAlignment>}\n     */\n    var parseTableAlign = function(source, parse, state, trimEndSeparators) {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleASTNode[][]}\n     */\n    var parseTableRow = function(source, parse, state, trimEndSeparators) {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        /** @type {SimpleMarkdown.SingleASTNode[][]} */\n        var cells = [[]];\n        tableRow.forEach(function(node, i) {\n            if (node.type === 'tableSeparator') {\n                // Filter out empty table separators at the start/end:\n                if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (node.type === 'text' && (\n                    tableRow[i + 1] == null ||\n                    tableRow[i + 1].type === 'tableSeparator'\n                )) {\n                    node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    /**\n     * @param {string} source\n     * @param {SimpleMarkdown.Parser} parse\n     * @param {SimpleMarkdown.State} state\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.ASTNode[][]}\n     */\n    var parseTableCells = function(source, parse, state, trimEndSeparators) {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    /**\n     * @param {boolean} trimEndSeparators\n     * @returns {SimpleMarkdown.SingleNodeParseFunction}\n     */\n    var parseTable = function(trimEndSeparators) {\n        /** @type {SimpleMarkdown.SingleNodeParseFunction} */\n        return function(capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n            var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n            var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n        \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\n/**\n * @param {SimpleMarkdown.Capture} capture\n * @param {SimpleMarkdown.State} state\n * @param {SimpleMarkdown.RefNode} refNode\n * @returns {SimpleMarkdown.RefNode}\n */\nvar parseRef = function(capture, state, refNode /* : RefNode */) {\n    var ref = (capture[2] || capture[1])\n        .replace(/\\s+/g, ' ')\n        .toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\n/** @type {SimpleMarkdown.DefaultRules} */\nvar defaultRules /* : DefaultRules */ = {\n    Array: {\n        react: function(arr, output, state) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = '' + i;\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function(arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0; i < arr.length; i++) {\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        }\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2].trim(), state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'h' + node.level,\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        }\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === '=' ? 1 : 2,\n                content: parseInline(parse, capture[1], state)\n            };\n        },\n        react: null,\n        html: null\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'hr',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<hr>\";\n        }\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            var content = capture[0]\n                .replace(/^    /gm, '')\n                .replace(/\\n+$/, '');\n            return {\n                lang: undefined,\n                content: content\n            };\n        },\n        react: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            return reactElement(\n                'pre',\n                state.key,\n                {\n                    children: reactElement(\n                        'code',\n                        null,\n                        {\n                            className: className,\n                            children: node.content\n                        }\n                    )\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className\n            });\n            return htmlTag(\"pre\", codeBlock);\n        }\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3]\n            };\n        },\n        react: null,\n        html: null\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function(capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, '');\n            return {\n                content: parse(content, state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'blockquote',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        }\n    },\n    list: {\n        order: currOrder++,\n        match: function(source, state) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function(capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items = /** @type {string[]} */ (\n                capture[0]\n                    .replace(LIST_BLOCK_END_R, \"\\n\")\n                    .match(LIST_ITEM_R)\n            );\n\n            // We know this will match here, because of how the regexes are\n            // defined\n            /*:: items = ((items : any) : Array<string>) */\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function(/** @type {string} */ item, /** @type {number} */ i) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                         // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                         // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                // I'm not sur4 why this is necessary again?\n                /*:: items = ((items : any) : Array<string>) */\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = (i === items.length - 1);\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph = containsBlocks ||\n                        (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent\n            };\n        },\n        react: function(node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(\n                ListWrapper,\n                state.key,\n                {\n                    start: node.start,\n                    children: node.items.map(function(\n                        /** @type {SimpleMarkdown.ASTNode} */ item,\n                        /** @type {number} */ i\n                    ) {\n                        return reactElement(\n                            'li',\n                            '' + i,\n                            {\n                                children: output(item, state)\n                            }\n                        );\n                    })\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var listItems = node.items.map(function(/** @type {SimpleMarkdown.ASTNode} */ item) {\n                return htmlTag(\"li\", output(item, state));\n            }).join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return htmlTag(listTag, listItems, attributes);\n        }\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/\n        ),\n        parse: function(capture, parse, state) {\n            var def = capture[1]\n                .replace(/\\s+/g, ' ')\n                .toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function(/** @type {SimpleMarkdown.RefNode} */ refNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function() { return null; },\n        html: function() { return \"\"; }\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {{ [attr: string]: SimpleMarkdown.Attr }}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? {} : {\n                    textAlign: node.align[colIndex]\n                };\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return reactElement(\n                    'th',\n                    '' + i,\n                    {\n                        style: getStyle(i),\n                        scope: 'col',\n                        children: output(content, state)\n                    }\n                );\n            });\n\n            var rows = node.cells.map(function(\n                    /** @type {SimpleMarkdown.ASTNode[]} */ row,\n                    /** @type {number} */ r\n            ) {\n                return reactElement(\n                    'tr',\n                    '' + r,\n                    {\n                        children: row.map(function(\n                            /** @type {SimpleMarkdown.ASTNode} */ content,\n                            /** @type {number} */ c\n                        ) {\n                            return reactElement(\n                                'td',\n                                '' + c,\n                                {\n                                    style: getStyle(c),\n                                    children: output(content, state)\n                                }\n                            );\n                        })\n                    }\n                );\n            });\n\n            return reactElement(\n                'table',\n                state.key,\n                {\n                    children: [reactElement(\n                        'thead',\n                        'thead',\n                        {\n                            children: reactElement(\n                                'tr',\n                                null,\n                                {\n                                    children: headers\n                                }\n                            )\n                        }\n                    ), reactElement(\n                        'tbody',\n                        'tbody',\n                        {\n                            children: rows\n                        }\n                    )]\n                }\n            );\n        },\n        html: function(node, output, state) {\n            /**\n             * @param {number} colIndex\n             * @returns {string}\n             */\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(\n                /** @type {SimpleMarkdown.ASTNode} */ content,\n                /** @type {number} */ i\n            ) {\n                return htmlTag(\"th\", output(content, state),\n                    { style: getStyle(i), scope: \"col\" });\n            }).join(\"\");\n\n            var rows = node.cells.map(function(/** @type {SimpleMarkdown.ASTNode[]} */ row) {\n                var cols = row.map(function(\n                    /** @type {SimpleMarkdown.ASTNode} */ content,\n                    /** @type {number} */ c\n                ) {\n                    return htmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                }).join(\"\");\n\n                return htmlTag(\"tr\", cols);\n            }).join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        }\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) { return \"\\n\"; },\n        html: function(node, output, state) { return \"\\n\"; }\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'div',\n                state.key,\n                {\n                    className: 'paragraph',\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        }\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    tableSeparator: {\n        order: currOrder++,\n        match: function(source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function() {\n            return { type: 'tableSeparator' };\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function() { return ' | '; },\n        html: function() { return ' &vert; '; },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: address\n                }],\n                target: target\n            };\n        },\n        react: null,\n        html: null\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1],\n                title: undefined\n            };\n        },\n        react: null,\n        html: null\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var link ={\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return link;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'a',\n                state.key,\n                {\n                    href: sanitizeUrl(node.target),\n                    title: node.title,\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        }\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return image;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'img',\n                state.key,\n                {\n                    src: sanitizeUrl(node.target),\n                    alt: node.alt,\n                    title: node.title\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        }\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state)\n            });\n        },\n        react: null,\n        html: null\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1]\n            });\n        },\n        react: null,\n        html: null\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                \"\\\\b\" +\n                // Or match *s:\n                \"|\" +\n                // Only match *s that are followed by a non-space:\n                \"^\\\\*(?=\\\\S)(\" +\n                // Match at least one of:\n                \"(?:\" +\n                  //  - `**`: so that bolds inside italics don't close the\n                  //          italics\n                  \"\\\\*\\\\*|\" +\n                  //  - escape sequence: so escaped *s don't close us\n                  \"\\\\\\\\[\\\\s\\\\S]|\" +\n                  //  - whitespace: followed by a non-* (we don't\n                  //          want ' *' to close an italics--it might\n                  //          start a list)\n                  \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                  //  - non-whitespace, non-*, non-backslash characters\n                  \"[^\\\\s\\\\*\\\\\\\\]\" +\n                \")+?\" +\n                // followed by a non-space, non-* then *\n                \")\\\\*(?!\\\\*)\"\n            )\n        ),\n        quality: function(capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'em',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        }\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function(capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'strong',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        }\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function(capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'u',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        }\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'del',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        }\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'code',\n                state.key,\n                {\n                    children: node.content\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        }\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'br',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<br>\";\n        }\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[0]\n            };\n        },\n        react: function(node, output, state) {\n            return node.content;\n        },\n        html: function(node, output, state) {\n            return sanitizeText(node.content);\n        }\n    }\n};\n\n/** (deprecated)\n * @param {any} rules\n * @param {any} property\n * @returns {any}\n */\nvar ruleOutput = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\"simple-markdown ruleOutput should take 'react' or \" +\n            \"'html' as the second argument.\"\n        );\n    }\n\n    /** @type {SimpleMarkdown.NodeOutput<any>} */\n    var nestedRuleOutput /* : NodeOutput<any> */ = function(\n        ast /* : SingleASTNode */,\n        outputFunc /* : Output<any> */,\n        state /* : State */\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar reactFor = function(outputFunc /* : ReactNodeOutput */) /* : ReactOutput */ {\n    /** @type {SimpleMarkdown.ReactOutput} */\n    var nestedOutput /* : ReactOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = '' + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/** (deprecated)\n * @param {any} outputFunc\n * @returns {any}\n */\nvar htmlFor = function(outputFunc /* : HtmlNodeOutput */) /* : HtmlOutput */ {\n    /** @type {SimpleMarkdown.HtmlOutput} */\n    var nestedOutput /* : HtmlOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast.map(function(node) {\n                return nestedOutput(node, state);\n            }).join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\n/**\n * @type {SimpleMarkdown.OutputFor}\n */\nvar outputFor = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */,\n    defaultState /* : ?State */\n) {\n    if (!property) {\n        throw new Error('simple-markdown: outputFor: `property` must be ' +\n            'defined. ' +\n            'if you just upgraded, you probably need to replace `outputFor` ' +\n            'with `reactFor`'\n        );\n    }\n\n    /** @type {SimpleMarkdown.State} */\n    var latestState;\n    /** @type {SimpleMarkdown.ArrayRule} */\n    var arrayRule = rules.Array || defaultRules.Array;\n\n    // Tricks to convince tsc that this var is not null:\n    var arrayRuleCheck = arrayRule[property];\n    if (!arrayRuleCheck) {\n        throw new Error('simple-markdown: outputFor: to join nodes of type `' +\n            property + '` you must provide an `Array:` joiner rule with that type, ' +\n            'Please see the docs for details on specifying an Array rule.'\n        );\n    }\n    var arrayRuleOutput = arrayRuleCheck;\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var nestedOutput /* : Output<any> */ = function(ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRuleOutput(ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    /** @type {SimpleMarkdown.Output<any>} */\n    var outerOutput = function(ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\nvar defaultRawParse = parserFor(defaultRules);\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultBlockParse = function(source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultInlineParse = function(source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {Array<SimpleMarkdown.SingleASTNode>}\n */\nvar defaultImplicitParse = function(source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\n/** @type {SimpleMarkdown.ReactOutput} */\nvar defaultReactOutput /* : ReactOutput */ = outputFor(defaultRules, \"react\");\n/** @type {SimpleMarkdown.HtmlOutput} */\nvar defaultHtmlOutput /* : HtmlOutput */ = outputFor(defaultRules, \"html\");\n\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {SimpleMarkdown.ReactElements}\n */\nvar markdownToReact = function(source, state) /* : ReactElements */ {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n/**\n * @param {string} source\n * @param {SimpleMarkdown.OptionalState} [state]\n * @returns {string}\n */\nvar markdownToHtml = function(source, state) /* : string */ {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\n/**\n * @param {SimpleMarkdown.ReactMarkdownProps} props\n * @returns {SimpleMarkdown.ReactElement}\n */\nvar ReactMarkdown = function(props) {\n    /** @type {Object} */\n    var divProps = {};\n\n    for (var prop in props) {\n        if (prop !== 'source' &&\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\n        'div',\n        null,\n        divProps\n    );\n};\n\n\n/*:: // Flow exports:\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n\n    +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (tagName: string, content: string, attributes: ?{ [any]: ?Attr }, isClosed: ?boolean) => string,\n    +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n};\n*/\n\nvar SimpleMarkdown /* : Exports */ = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n        }\n        return defaultImplicitParse.apply(null, /** @type {any} */ (arguments));\n    },\n    defaultOutput: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n        }\n        return defaultReactOutput.apply(null, /** @type {any} */ (arguments));\n    }\n};\n\nreturn SimpleMarkdown;\n\n})));\n"],"mappings":"AAAC,WAAUA,MAAM,EAAEC,OAAO,EAAE;EAC5B,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOC,MAAM,KAAK,WAAW,GAAGA,MAAM,CAACD,OAAO,GAAGD,OAAO,CAAC,CAAC,GACzF,OAAOG,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,GAAGD,MAAM,CAACH,OAAO,CAAC,IAC3DD,MAAM,GAAGA,MAAM,IAAIM,IAAI,EAAEN,MAAM,CAACO,cAAc,GAAGN,OAAO,CAAC,CAAC,CAAC;AAC5D,CAAC,EAAC,IAAI,EAAG,YAAY;EAAE,YAAY;;EAEnC;EACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEA;EACA;EACA;;EAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEA,IAAIO,YAAY,GAAG,QAAQ;EAC3B,IAAIC,KAAK,GAAG,KAAK;EACjB,IAAIC,UAAU,GAAG,KAAK;;EAEtB;AACA;AACA;AACA;AACA;EACA,IAAIC,UAAU,GAAG,SAAAA,CAASC,MAAM,CAAC,gBAAgB;IAC7C,OAAOA,MAAM,CAACC,OAAO,CAACL,YAAY,EAAE,IAAI,CAAC,CAChCK,OAAO,CAACH,UAAU,EAAE,EAAE,CAAC,CACvBG,OAAO,CAACJ,KAAK,EAAE,MAAM,CAAC;EACnC,CAAC;;EAED;AACA;AACA;AACA;AACA;EACA,IAAIK,oBAAoB,GAAG,SAAAA,CACvBC,UAAU,CAAC,gBACXC,YAAY,CAAC,gBACf,aAAa;IACX,IAAIC,KAAK,CAAC,gBAAgBF,UAAU,IAAI,CAAC,CAAC;IAC1C,IAAIC,YAAY,IAAI,IAAI,EAAE;MACtB,KAAK,IAAIE,IAAI,IAAIF,YAAY,EAAE;QAC3B,IAAIG,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACN,YAAY,EAAEE,IAAI,CAAC,EAAE;UAC1DD,KAAK,CAACC,IAAI,CAAC,GAAGF,YAAY,CAACE,IAAI,CAAC;QACpC;MACJ;IACJ;IACA,OAAOD,KAAK;EAChB,CAAC;;EAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,IAAIM,SAAS,GAAG,SAAAA,CAASC,KAAK,CAAC,oB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","ignoreList":[]},"metadata":{},"sourceType":"script"}