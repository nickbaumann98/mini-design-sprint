{"ast":null,"code":"/**\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback CreateElementLike\n *   Function that works somewhat like `React.createElement`.\n * @param {string} name\n *   Element name.\n * @param {any} attributes\n *   Properties.\n * @param {Array<any>} [children]\n *   Children.\n * @returns {any}\n *   Something.\n *\n * @typedef State\n *   Info passed around.\n * @property {Schema} schema\n *   Current schema.\n * @property {string | undefined} prefix\n *   Prefix to use.\n * @property {number} key\n *   Current key.\n * @property {boolean} react\n *   Looks like React.\n * @property {boolean} vue\n *   Looks like Vue.\n * @property {boolean} vdom\n *   Looks like vdom.\n * @property {boolean} hyperscript\n *   Looks like `hyperscript`.\n *\n * @typedef Options\n *   Configuration.\n * @property {string | null | undefined} [prefix]\n *   Prefix to use as a prefix for keys passed in `props` to `h()`, this\n *   behavior is turned off by passing `false` and turned on by passing a\n *   `string`.\n *   By default, `h-` is used as a prefix if the given `h` is detected as being\n *   `virtual-dom/h` or `React.createElement`\n * @property {'html' | 'svg' | null | undefined} [space]\n *   Whether `node` is in the `'html'` or `'svg'` space.\n *   If an `<svg>` element is found when inside the HTML space, `toH`\n *   automatically switches to the SVG space when entering the element, and\n *   switches back when exiting.\n */\n\nimport { html, svg, find, hastToReact } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport { stringify as commas } from 'comma-separated-tokens';\nimport styleToObject from 'style-to-object';\nimport { webNamespaces } from 'web-namespaces';\nconst own = {}.hasOwnProperty;\n\n/**\n * @template {CreateElementLike} H\n *   Type of hyperscript function.\n * @param {H} h\n *   HyperScript function.\n * @param {Node} tree\n *   Tree to transform.\n * @param {string | boolean | Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ReturnType<H>}\n *   Return type of the hyperscript function.\n */\n// eslint-disable-next-line complexity\nexport function toH(h, tree, options) {\n  if (typeof h !== 'function') {\n    throw new TypeError('h is not a function');\n  }\n  const r = react(h);\n  const v = vue(h);\n  const vd = vdom(h);\n  /** @type {string|boolean|null|undefined} */\n  let prefix;\n  /** @type {Element} */\n  let node;\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    prefix = options;\n    options = {};\n  } else {\n    if (!options) options = {};\n    prefix = options.prefix;\n  }\n  if (tree && tree.type === 'root') {\n    const head = tree.children[0];\n    // @ts-expect-error Allow `doctypes` in there, we’ll filter them out later.\n    node = tree.children.length === 1 && head.type === 'element' ? head : {\n      type: 'element',\n      tagName: 'div',\n      properties: {},\n      children: tree.children\n    };\n  } else if (tree && tree.type === 'element') {\n    node = tree;\n  } else {\n    throw new Error('Expected root or element, not `' + (tree && tree.type || tree) + '`');\n  }\n  return transform(h, node, {\n    schema: options.space === 'svg' ? svg : html,\n    prefix: prefix === undefined || prefix === null ? r || v || vd ? 'h-' : undefined : typeof prefix === 'string' ? prefix : prefix ? 'h-' : undefined,\n    key: 0,\n    react: r,\n    vue: v,\n    vdom: vd,\n    hyperscript: hyperscript(h)\n  });\n}\n\n/**\n * Transform a hast node through a hyperscript interface to *anything*!\n *\n * @template {CreateElementLike} H\n *   Type of hyperscript function.\n * @param {H} h\n *   HyperScript function.\n * @param {Element} node\n *   Node to transform.\n * @param {State} state\n *   Info passed around.\n * @returns {ReturnType<H>}\n *   Return type of the hyperscript function.\n */\nfunction transform(h, node, state) {\n  const parentSchema = state.schema;\n  let schema = parentSchema;\n  let name = node.tagName;\n  /** @type {Record<string, unknown>} */\n  const attributes = {};\n  /** @type {Array<ReturnType<H>|string>} */\n  const nodes = [];\n  let index = -1;\n  /** @type {string} */\n  let key;\n  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {\n    schema = svg;\n    state.schema = schema;\n  }\n  for (key in node.properties) {\n    if (node.properties && own.call(node.properties, key)) {\n      addAttribute(attributes, key, node.properties[key], state, name);\n    }\n  }\n  if (state.vdom) {\n    if (schema.space === 'html') {\n      name = name.toUpperCase();\n    } else if (schema.space) {\n      attributes.namespace = webNamespaces[schema.space];\n    }\n  }\n  if (state.prefix) {\n    state.key++;\n    attributes.key = state.prefix + state.key;\n  }\n  if (node.children) {\n    while (++index < node.children.length) {\n      const value = node.children[index];\n      if (value.type === 'element') {\n        nodes.push(transform(h, value, state));\n      } else if (value.type === 'text') {\n        nodes.push(value.value);\n      }\n    }\n  }\n\n  // Restore parent schema.\n  state.schema = parentSchema;\n\n  // Ensure no React warnings are triggered for void elements having children\n  // passed in.\n  return nodes.length > 0 ? h.call(node, name, attributes, nodes) : h.call(node, name, attributes);\n}\n\n/**\n * Add an attribute to `props`.\n *\n * @param {Record<string, unknown>} props\n *   Map.\n * @param {string} prop\n *   Key.\n * @param {unknown} value\n *   Value.\n * @param {State} state\n *   Info passed around.\n * @param {string} name\n *   Element name.\n * @returns {void}\n *   Nothing.\n */\n// eslint-disable-next-line complexity, max-params\nfunction addAttribute(props, prop, value, state, name) {\n  const info = find(state.schema, prop);\n  /** @type {string | undefined} */\n  let subprop;\n\n  // Ignore nullish and `NaN` values.\n  // Ignore `false` and falsey known booleans for hyperlike DSLs.\n  if (value === undefined || value === null || typeof value === 'number' && Number.isNaN(value) || value === false && (state.vue || state.vdom || state.hyperscript) || !value && info.boolean && (state.vue || state.vdom || state.hyperscript)) {\n    return;\n  }\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  }\n\n  // Treat `true` and truthy known booleans.\n  if (info.boolean && state.hyperscript) {\n    value = '';\n  }\n\n  // VDOM, Vue, and React accept `style` as object.\n  if (info.property === 'style' && typeof value === 'string' && (state.react || state.vue || state.vdom)) {\n    value = parseStyle(value, name);\n  }\n\n  // Vue 3 (used in our tests) doesn’t need this anymore.\n  // Some major in the future we can drop Vue 2 support.\n  /* c8 ignore next 2 */\n  if (state.vue) {\n    if (info.property !== 'style') subprop = 'attrs';\n  } else if (!info.mustUseProperty) {\n    if (state.vdom) {\n      if (info.property !== 'style') subprop = 'attributes';\n    } else if (state.hyperscript) {\n      subprop = 'attrs';\n    }\n  }\n  if (subprop) {\n    props[subprop] = Object.assign(props[subprop] || {}, {\n      [info.attribute]: value\n    });\n  } else if (info.space && state.react) {\n    props[hastToReact[info.property] || info.property] = value;\n  } else {\n    props[info.attribute] = value;\n  }\n}\n\n/**\n * Check if `h` is `react.createElement`.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like React.\n */\nfunction react(h) {\n  const node = /** @type {unknown} */h('div', {});\n  return Boolean(node && (\n  // @ts-expect-error Looks like a React node.\n  '_owner' in node || '_store' in node) && (\n  // @ts-expect-error Looks like a React node.\n  node.key === undefined || node.key === null));\n}\n\n/**\n * Check if `h` is `hyperscript`.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like `hyperscript`.\n */\nfunction hyperscript(h) {\n  return 'context' in h && 'cleanup' in h;\n}\n\n/**\n * Check if `h` is `virtual-dom/h`.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like `virtual-dom`\n */\nfunction vdom(h) {\n  const node = /** @type {unknown} */h('div', {});\n  // @ts-expect-error Looks like a vnode.\n  return node.type === 'VirtualNode';\n}\n\n/**\n * Check if `h` is Vue.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like Vue.\n */\nfunction vue(h) {\n  // Vue 3 (used in our tests) doesn’t need this anymore.\n  // Some major in the future we can drop Vue 2 support.\n  /* c8 ignore next 3 */\n  const node = /** @type {unknown} */h('div', {});\n  // @ts-expect-error Looks like a Vue node.\n  return Boolean(node && node.context && node.context._isVue);\n}\n\n/**\n * Parse a declaration into an object.\n *\n * @param {string} value\n *   CSS declarations.\n * @param {string} tagName\n *   Tag name.\n * @returns {Record<string, string>}\n *   Properties.\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Record<string, string>} */\n  const result = {};\n  try {\n    styleToObject(value, (name, value) => {\n      if (name.slice(0, 4) === '-ms-') name = 'ms-' + name.slice(4);\n      result[name.replace(/-([a-z])/g,\n      /**\n       * @param {string} _\n       * @param {string} $1\n       * @returns {string}\n       */\n      (_, $1) => $1.toUpperCase())] = value;\n    });\n  } catch (error_) {\n    const error = /** @type {Error} */error_;\n    error.message = tagName + '[style]' + error.message.slice('undefined'.length);\n    throw error;\n  }\n  return result;\n}","map":{"version":3,"names":["html","svg","find","hastToReact","stringify","spaces","commas","styleToObject","webNamespaces","own","hasOwnProperty","toH","h","tree","options","TypeError","r","react","v","vue","vd","vdom","prefix","node","type","head","children","length","tagName","properties","Error","transform","schema","space","undefined","key","hyperscript","state","parentSchema","name","attributes","nodes","index","toLowerCase","call","addAttribute","toUpperCase","namespace","value","push","props","prop","info","subprop","Number","isNaN","boolean","Array","isArray","commaSeparated","property","parseStyle","mustUseProperty","Object","assign","attribute","Boolean","context","_isVue","result","slice","replace","_","$1","error_","error","message"],"sources":["/Users/nickbaumann/Develop/mini-design-sprint/node_modules/hast-to-hyperscript/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('property-information').Schema} Schema\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback CreateElementLike\n *   Function that works somewhat like `React.createElement`.\n * @param {string} name\n *   Element name.\n * @param {any} attributes\n *   Properties.\n * @param {Array<any>} [children]\n *   Children.\n * @returns {any}\n *   Something.\n *\n * @typedef State\n *   Info passed around.\n * @property {Schema} schema\n *   Current schema.\n * @property {string | undefined} prefix\n *   Prefix to use.\n * @property {number} key\n *   Current key.\n * @property {boolean} react\n *   Looks like React.\n * @property {boolean} vue\n *   Looks like Vue.\n * @property {boolean} vdom\n *   Looks like vdom.\n * @property {boolean} hyperscript\n *   Looks like `hyperscript`.\n *\n * @typedef Options\n *   Configuration.\n * @property {string | null | undefined} [prefix]\n *   Prefix to use as a prefix for keys passed in `props` to `h()`, this\n *   behavior is turned off by passing `false` and turned on by passing a\n *   `string`.\n *   By default, `h-` is used as a prefix if the given `h` is detected as being\n *   `virtual-dom/h` or `React.createElement`\n * @property {'html' | 'svg' | null | undefined} [space]\n *   Whether `node` is in the `'html'` or `'svg'` space.\n *   If an `<svg>` element is found when inside the HTML space, `toH`\n *   automatically switches to the SVG space when entering the element, and\n *   switches back when exiting.\n */\n\nimport {html, svg, find, hastToReact} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {stringify as commas} from 'comma-separated-tokens'\nimport styleToObject from 'style-to-object'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @template {CreateElementLike} H\n *   Type of hyperscript function.\n * @param {H} h\n *   HyperScript function.\n * @param {Node} tree\n *   Tree to transform.\n * @param {string | boolean | Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ReturnType<H>}\n *   Return type of the hyperscript function.\n */\n// eslint-disable-next-line complexity\nexport function toH(h, tree, options) {\n  if (typeof h !== 'function') {\n    throw new TypeError('h is not a function')\n  }\n\n  const r = react(h)\n  const v = vue(h)\n  const vd = vdom(h)\n  /** @type {string|boolean|null|undefined} */\n  let prefix\n  /** @type {Element} */\n  let node\n\n  if (typeof options === 'string' || typeof options === 'boolean') {\n    prefix = options\n    options = {}\n  } else {\n    if (!options) options = {}\n    prefix = options.prefix\n  }\n\n  if (tree && tree.type === 'root') {\n    const head = tree.children[0]\n    // @ts-expect-error Allow `doctypes` in there, we’ll filter them out later.\n    node =\n      tree.children.length === 1 && head.type === 'element'\n        ? head\n        : {\n            type: 'element',\n            tagName: 'div',\n            properties: {},\n            children: tree.children\n          }\n  } else if (tree && tree.type === 'element') {\n    node = tree\n  } else {\n    throw new Error(\n      'Expected root or element, not `' + ((tree && tree.type) || tree) + '`'\n    )\n  }\n\n  return transform(h, node, {\n    schema: options.space === 'svg' ? svg : html,\n    prefix:\n      prefix === undefined || prefix === null\n        ? r || v || vd\n          ? 'h-'\n          : undefined\n        : typeof prefix === 'string'\n        ? prefix\n        : prefix\n        ? 'h-'\n        : undefined,\n    key: 0,\n    react: r,\n    vue: v,\n    vdom: vd,\n    hyperscript: hyperscript(h)\n  })\n}\n\n/**\n * Transform a hast node through a hyperscript interface to *anything*!\n *\n * @template {CreateElementLike} H\n *   Type of hyperscript function.\n * @param {H} h\n *   HyperScript function.\n * @param {Element} node\n *   Node to transform.\n * @param {State} state\n *   Info passed around.\n * @returns {ReturnType<H>}\n *   Return type of the hyperscript function.\n */\nfunction transform(h, node, state) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n  let name = node.tagName\n  /** @type {Record<string, unknown>} */\n  const attributes = {}\n  /** @type {Array<ReturnType<H>|string>} */\n  const nodes = []\n  let index = -1\n  /** @type {string} */\n  let key\n\n  if (parentSchema.space === 'html' && name.toLowerCase() === 'svg') {\n    schema = svg\n    state.schema = schema\n  }\n\n  for (key in node.properties) {\n    if (node.properties && own.call(node.properties, key)) {\n      addAttribute(attributes, key, node.properties[key], state, name)\n    }\n  }\n\n  if (state.vdom) {\n    if (schema.space === 'html') {\n      name = name.toUpperCase()\n    } else if (schema.space) {\n      attributes.namespace = webNamespaces[schema.space]\n    }\n  }\n\n  if (state.prefix) {\n    state.key++\n    attributes.key = state.prefix + state.key\n  }\n\n  if (node.children) {\n    while (++index < node.children.length) {\n      const value = node.children[index]\n\n      if (value.type === 'element') {\n        nodes.push(transform(h, value, state))\n      } else if (value.type === 'text') {\n        nodes.push(value.value)\n      }\n    }\n  }\n\n  // Restore parent schema.\n  state.schema = parentSchema\n\n  // Ensure no React warnings are triggered for void elements having children\n  // passed in.\n  return nodes.length > 0\n    ? h.call(node, name, attributes, nodes)\n    : h.call(node, name, attributes)\n}\n\n/**\n * Add an attribute to `props`.\n *\n * @param {Record<string, unknown>} props\n *   Map.\n * @param {string} prop\n *   Key.\n * @param {unknown} value\n *   Value.\n * @param {State} state\n *   Info passed around.\n * @param {string} name\n *   Element name.\n * @returns {void}\n *   Nothing.\n */\n// eslint-disable-next-line complexity, max-params\nfunction addAttribute(props, prop, value, state, name) {\n  const info = find(state.schema, prop)\n  /** @type {string | undefined} */\n  let subprop\n\n  // Ignore nullish and `NaN` values.\n  // Ignore `false` and falsey known booleans for hyperlike DSLs.\n  if (\n    value === undefined ||\n    value === null ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (value === false && (state.vue || state.vdom || state.hyperscript)) ||\n    (!value && info.boolean && (state.vue || state.vdom || state.hyperscript))\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  // Treat `true` and truthy known booleans.\n  if (info.boolean && state.hyperscript) {\n    value = ''\n  }\n\n  // VDOM, Vue, and React accept `style` as object.\n  if (\n    info.property === 'style' &&\n    typeof value === 'string' &&\n    (state.react || state.vue || state.vdom)\n  ) {\n    value = parseStyle(value, name)\n  }\n\n  // Vue 3 (used in our tests) doesn’t need this anymore.\n  // Some major in the future we can drop Vue 2 support.\n  /* c8 ignore next 2 */\n  if (state.vue) {\n    if (info.property !== 'style') subprop = 'attrs'\n  } else if (!info.mustUseProperty) {\n    if (state.vdom) {\n      if (info.property !== 'style') subprop = 'attributes'\n    } else if (state.hyperscript) {\n      subprop = 'attrs'\n    }\n  }\n\n  if (subprop) {\n    props[subprop] = Object.assign(props[subprop] || {}, {\n      [info.attribute]: value\n    })\n  } else if (info.space && state.react) {\n    props[hastToReact[info.property] || info.property] = value\n  } else {\n    props[info.attribute] = value\n  }\n}\n\n/**\n * Check if `h` is `react.createElement`.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like React.\n */\nfunction react(h) {\n  const node = /** @type {unknown} */ (h('div', {}))\n  return Boolean(\n    node &&\n      // @ts-expect-error Looks like a React node.\n      ('_owner' in node || '_store' in node) &&\n      // @ts-expect-error Looks like a React node.\n      (node.key === undefined || node.key === null)\n  )\n}\n\n/**\n * Check if `h` is `hyperscript`.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like `hyperscript`.\n */\nfunction hyperscript(h) {\n  return 'context' in h && 'cleanup' in h\n}\n\n/**\n * Check if `h` is `virtual-dom/h`.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like `virtual-dom`\n */\nfunction vdom(h) {\n  const node = /** @type {unknown} */ (h('div', {}))\n  // @ts-expect-error Looks like a vnode.\n  return node.type === 'VirtualNode'\n}\n\n/**\n * Check if `h` is Vue.\n *\n * @param {CreateElementLike} h\n *   HyperScript function.\n * @returns {boolean}\n *   Looks like Vue.\n */\nfunction vue(h) {\n  // Vue 3 (used in our tests) doesn’t need this anymore.\n  // Some major in the future we can drop Vue 2 support.\n  /* c8 ignore next 3 */\n  const node = /** @type {unknown} */ (h('div', {}))\n  // @ts-expect-error Looks like a Vue node.\n  return Boolean(node && node.context && node.context._isVue)\n}\n\n/**\n * Parse a declaration into an object.\n *\n * @param {string} value\n *   CSS declarations.\n * @param {string} tagName\n *   Tag name.\n * @returns {Record<string, string>}\n *   Properties.\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Record<string, string>} */\n  const result = {}\n\n  try {\n    styleToObject(value, (name, value) => {\n      if (name.slice(0, 4) === '-ms-') name = 'ms-' + name.slice(4)\n\n      result[\n        name.replace(\n          /-([a-z])/g,\n          /**\n           * @param {string} _\n           * @param {string} $1\n           * @returns {string}\n           */\n          (_, $1) => $1.toUpperCase()\n        )\n      ] = value\n    })\n  } catch (error_) {\n    const error = /** @type {Error} */ (error_)\n    error.message =\n      tagName + '[style]' + error.message.slice('undefined'.length)\n    throw error\n  }\n\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}